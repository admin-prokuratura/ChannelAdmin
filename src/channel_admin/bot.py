"""Executable Telegram bot wiring for the Channel Admin service."""

from __future__ import annotations

import asyncio
import logging
import os
from datetime import timedelta

from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    AIORateLimiter,
    ApplicationBuilder,
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

from .config import FilterConfig, PricingConfig
from .services import ChannelEconomyService
from .storage import InMemoryStorage
from .payments import CryptoPayClient, CryptoPayError

LOGGER = logging.getLogger(__name__)


def build_service() -> ChannelEconomyService:
    pricing = PricingConfig()
    filter_config = FilterConfig()
    storage = InMemoryStorage()
    return ChannelEconomyService(storage=storage, pricing=pricing, filter_config=filter_config)


def build_crypto_client() -> CryptoPayClient | None:
    token = os.environ.get("CRYPTOPAY_TOKEN")
    if not token:
        LOGGER.warning("CRYPTOPAY_TOKEN is not configured; payments will be disabled")
        return None
    return CryptoPayClient(token=token)


def ensure_dependencies(context: ContextTypes.DEFAULT_TYPE) -> None:
    context.application.bot_data.setdefault("service", build_service())
    context.application.bot_data.setdefault("crypto", build_crypto_client())


def main_menu_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton("üìä –ë–∞–ª–∞–Ω—Å", callback_data="action:balance"),
                InlineKeyboardButton("‚ö°Ô∏è –ü–æ–ø–æ–ª–Ω–∏—Ç—å —ç–Ω–µ—Ä–≥–∏—é", callback_data="action:energy"),
            ],
            [
                InlineKeyboardButton(
                    "üåü –ó–æ–ª–æ—Ç–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞", callback_data="action:golden_card"
                ),
            ],
            [
                InlineKeyboardButton("üìù –û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ—Å—Ç", callback_data="action:post"),
            ],
        ]
    )


def energy_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton("50 ‚ö°Ô∏è", callback_data="energy:50"),
                InlineKeyboardButton("100 ‚ö°Ô∏è", callback_data="energy:100"),
            ],
            [
                InlineKeyboardButton("250 ‚ö°Ô∏è", callback_data="energy:250"),
            ],
            [InlineKeyboardButton("üîô –í –º–µ–Ω—é", callback_data="action:menu")],
        ]
    )


def golden_card_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton("12 —á", callback_data="golden:12"),
                InlineKeyboardButton("24 —á", callback_data="golden:24"),
            ],
            [InlineKeyboardButton("72 —á", callback_data="golden:72")],
            [InlineKeyboardButton("üîô –í –º–µ–Ω—é", callback_data="action:menu")],
        ]
    )


async def send_main_menu(update: Update, text: str) -> None:
    if update.message:
        await update.message.reply_text(text, reply_markup=main_menu_keyboard())
    elif update.callback_query:
        await update.callback_query.message.edit_text(text, reply_markup=main_menu_keyboard())


def get_service(context: ContextTypes.DEFAULT_TYPE) -> ChannelEconomyService:
    return context.application.bot_data.setdefault("service", build_service())


def get_crypto_client(context: ContextTypes.DEFAULT_TYPE) -> CryptoPayClient | None:
    client = context.application.bot_data.get("crypto")
    if client is None:
        client = build_crypto_client()
        if client:
            context.application.bot_data["crypto"] = client
    return client


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    service = get_service(context)
    try:
        service.register_user(update.effective_user.id, subscribed_to_sponsors=True)
    except ValueError as exc:
        await update.message.reply_text(str(exc))
        return
    ensure_dependencies(context)
    await update.message.reply_text(
        "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Channel Admin!\n"
        "–í—ã —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∏ –ø–æ–ª—É—á–∏–ª–∏ —Å—Ç–∞—Ä—Ç–æ–≤—É—é —ç–Ω–µ—Ä–≥–∏—é."
    )
    await send_main_menu(update, "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é üëá")


async def handle_menu_action(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    ensure_dependencies(context)
    query = update.callback_query
    assert query is not None
    await query.answer()
    action = query.data.split(":", 1)[1]

    if action == "menu":
        context.user_data.pop("awaiting_post", None)
        await query.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é üëá", reply_markup=main_menu_keyboard())
        return

    service = get_service(context)
    if action == "balance":
        user = service.get_user_balance(update.effective_user.id)
        if not user:
            await query.message.edit_text(
                "‚ùóÔ∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ù–∞–∂–º–∏—Ç–µ /start –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.",
                reply_markup=InlineKeyboardMarkup(
                    [[InlineKeyboardButton("üîô –í –º–µ–Ω—é", callback_data="action:menu")]]
                ),
            )
            return
        active_cards = sum(1 for card in user.golden_cards if card.expires_at > card.purchased_at)
        await query.message.edit_text(
            "üìä –í–∞—à –±–∞–ª–∞–Ω—Å:\n"
            f"‚Ä¢ ‚ö°Ô∏è –≠–Ω–µ—Ä–≥–∏—è: {user.energy}\n"
            f"‚Ä¢ üåü –ê–∫—Ç–∏–≤–Ω—ã–µ –∑–æ–ª–æ—Ç—ã–µ –∫–∞—Ä—Ç–æ—á–∫–∏: {active_cards}",
            reply_markup=InlineKeyboardMarkup(
                [[InlineKeyboardButton("üîô –í –º–µ–Ω—é", callback_data="action:menu")]]
            ),
        )
    elif action == "energy":
        await query.message.edit_text(
            "‚ö°Ô∏è –í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–∫–µ—Ç —ç–Ω–µ—Ä–≥–∏–∏ –¥–ª—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è:",
            reply_markup=energy_keyboard(),
        )
    elif action == "golden_card":
        await query.message.edit_text(
            "üåü –í—ã–±–µ—Ä–∏—Ç–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–æ–ª–æ—Ç–æ–π –∫–∞—Ä—Ç–æ—á–∫–∏:",
            reply_markup=golden_card_keyboard(),
        )
    elif action == "post":
        context.user_data["awaiting_post"] = True
        await query.message.edit_text(
            "üìù –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç –ø–æ—Å—Ç–∞ –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º.\n"
            "–ö–æ–≥–¥–∞ –±—É–¥–µ—Ç–µ –≥–æ—Ç–æ–≤—ã, –ø—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –µ–≥–æ –≤ —á–∞—Ç."
            "\n\n–î–ª—è –æ—Ç–º–µ–Ω—ã –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ.",
            reply_markup=InlineKeyboardMarkup(
                [[InlineKeyboardButton("üîô –û—Ç–º–µ–Ω–∞", callback_data="action:menu")]]
            ),
        )


async def balance(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    service = get_service(context)
    user = service.get_user_balance(update.effective_user.id)
    if not user:
        await update.message.reply_text("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start.")
        return
    await update.message.reply_text(
        f"–≠–Ω–µ—Ä–≥–∏—è: {user.energy}\n–ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–æ–ª–æ—Ç—ã—Ö –∫–∞—Ä—Ç–æ—á–µ–∫: {sum(1 for card in user.golden_cards if card.expires_at > card.purchased_at)}"
    )


async def buy_energy(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    service = get_service(context)
    if not context.args:
        await update.message.reply_text("–£–∫–∞–∂–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–Ω–µ—Ä–≥–∏–∏: /buy_energy 50")
        return
    amount = int(context.args[0])
    price = service.purchase_energy(update.effective_user.id, amount)
    await update.message.reply_text(f"–ü–æ–∫—É–ø–∫–∞ —É—Å–ø–µ—à–Ω–∞. –°—Ç–æ–∏–º–æ—Å—Ç—å: {price:.2f}‚ÇΩ")


async def buy_golden_card(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    service = get_service(context)
    if not context.args:
        await update.message.reply_text("–£–∫–∞–∂–∏—Ç–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤ —á–∞—Å–∞—Ö: /buy_golden_card 24")
        return
    hours = int(context.args[0])
    price = service.purchase_golden_card(update.effective_user.id, timedelta(hours=hours))
    await update.message.reply_text(f"–ó–æ–ª–æ—Ç–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞ –ø—Ä–∏–æ–±—Ä–µ—Ç–µ–Ω–∞. –°—Ç–æ–∏–º–æ—Å—Ç—å: {price:.2f}‚ÇΩ")


async def post(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    service = get_service(context)
    if not context.args:
        await update.message.reply_text("–£–∫–∞–∂–∏—Ç–µ —Ç–µ–∫—Å—Ç –ø–æ—Å—Ç–∞ –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã /post")
        return
    message = " ".join(context.args)
    try:
        new_post = service.submit_post(update.effective_user.id, message)
    except ValueError as exc:
        await update.message.reply_text(str(exc))
        return
    pin_text = " –ü–æ—Å—Ç –±—É–¥–µ—Ç –∑–∞–∫—Ä–µ–ø–ª—ë–Ω." if new_post.requires_pin else ""
    await update.message.reply_text(f"–ü–æ—Å—Ç –æ–¥–æ–±—Ä–µ–Ω –∏ –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –≤ –∫–∞–Ω–∞–ª.{pin_text}")


async def handle_energy_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    ensure_dependencies(context)
    query = update.callback_query
    assert query is not None
    await query.answer()
    try:
        amount = int(query.data.split(":", 1)[1])
    except (ValueError, IndexError):
        await query.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤—ã–±–æ—Ä", show_alert=True)
        return

    service = get_service(context)
    price = service.pricing.price_for_energy(amount)
    client = get_crypto_client(context)
    if client is None:
        await query.message.reply_text(
            "üí§ –ü–ª–∞—Ç—ë–∂–Ω—ã–π —à–ª—é–∑ –ø–æ–∫–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
        )
        return

    try:
        invoice = await client.create_invoice(
            amount=price,
            description=f"–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–∏ ({amount}‚ö°Ô∏è)",
            payload=f"energy:{update.effective_user.id}:{amount}",
        )
    except CryptoPayError as exc:
        await query.message.reply_text(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å—á—ë—Ç: {exc}")
        return

    await query.message.reply_text(
        "üí≥ –°—á—ë—Ç –¥–ª—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –≥–æ—Ç–æ–≤!\n"
        f"–°—É–º–º–∞ –∫ –æ–ø–ª–∞—Ç–µ: {price:.2f} ‚ÇΩ\n"
        f"–ü–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ –∏ –∑–∞–≤–µ—Ä—à–∏—Ç–µ –æ–ø–ª–∞—Ç—É: {invoice.pay_url}"
    )


async def handle_golden_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    ensure_dependencies(context)
    query = update.callback_query
    assert query is not None
    await query.answer()
    try:
        hours = int(query.data.split(":", 1)[1])
    except (ValueError, IndexError):
        await query.answer("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –≤—ã–±–æ—Ä", show_alert=True)
        return

    service = get_service(context)
    duration = timedelta(hours=hours)
    price = service.pricing.price_for_golden_card(duration)
    client = get_crypto_client(context)
    if client is None:
        await query.message.reply_text(
            "üí§ –ü–ª–∞—Ç—ë–∂–Ω—ã–π —à–ª—é–∑ –ø–æ–∫–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É."
        )
        return

    try:
        invoice = await client.create_invoice(
            amount=price,
            description=f"–ó–æ–ª–æ—Ç–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞ –Ω–∞ {hours}—á",
            payload=f"golden:{update.effective_user.id}:{hours}",
        )
    except CryptoPayError as exc:
        await query.message.reply_text(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å—á—ë—Ç: {exc}")
        return

    await query.message.reply_text(
        "üåü –°—á—ë—Ç –Ω–∞ –∑–æ–ª–æ—Ç—É—é –∫–∞—Ä—Ç–æ—á–∫—É –≥–æ—Ç–æ–≤!\n"
        f"–°—Ç–æ–∏–º–æ—Å—Ç—å: {price:.2f} ‚ÇΩ\n"
        f"–û–ø–ª–∞—Ç–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ: {invoice.pay_url}"
    )


async def handle_post_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not context.user_data.get("awaiting_post"):
        await update.message.reply_text(
            "üôå –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–æ—Ç–æ–º.",
            reply_markup=main_menu_keyboard(),
        )
        return

    text = update.message.text.strip()
    if not text:
        await update.message.reply_text("–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø—É—Å—Ç—ã–º. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑ ‚úçÔ∏è")
        return

    service = get_service(context)
    try:
        new_post = service.submit_post(update.effective_user.id, text)
    except ValueError as exc:
        await update.message.reply_text(f"‚ùå {exc}")
        return

    context.user_data.pop("awaiting_post", None)
    pin_text = " üìå –ü–æ—Å—Ç –±—É–¥–µ—Ç –∑–∞–∫—Ä–µ–ø–ª—ë–Ω." if new_post.requires_pin else ""
    await update.message.reply_text(
        "‚úÖ –ü–æ—Å—Ç –ø—Ä–∏–Ω—è—Ç –∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –Ω–∞ –º–æ–¥–µ—Ä–∞—Ü–∏—é!" + pin_text
    )
    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–µ–¥—É—é—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ üëá",
        reply_markup=main_menu_keyboard(),
    )


async def main() -> None:
    token = os.environ.get("TELEGRAM_BOT_TOKEN")
    if not token:
        raise RuntimeError("TELEGRAM_BOT_TOKEN environment variable is required")
    application = (
        ApplicationBuilder()
        .token(token)
        .rate_limiter(AIORateLimiter())
        .post_init(
            lambda app: (
                app.bot_data.setdefault("service", build_service()),
                app.bot_data.setdefault("crypto", build_crypto_client()),
            )
        )
        .build()
    )

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(handle_menu_action, pattern="^action:"))
    application.add_handler(CallbackQueryHandler(handle_energy_selection, pattern="^energy:"))
    application.add_handler(CallbackQueryHandler(handle_golden_selection, pattern="^golden:"))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_post_text))
    application.add_handler(CommandHandler("balance", balance))
    application.add_handler(CommandHandler("buy_energy", buy_energy))
    application.add_handler(CommandHandler("buy_golden_card", buy_golden_card))
    application.add_handler(CommandHandler("post", post))

    LOGGER.info("Bot started")
    await application.initialize()
    await application.start()
    try:
        await application.updater.start_polling()
        await application.updater.wait_until_closed()
    finally:
        await application.stop()
        await application.shutdown()


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    asyncio.run(main())
